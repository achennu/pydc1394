2010. Feb. 08:
	Processing the conversions.h to the library. There are a couple useful
	things in here, which were missing so far. For example to use RGB
	displays, these can help converting any image buffers to RGB8 formats.
	I would suggest them implemented into the Image class.

	Adding new enums:
		bayer_method_t
		stereo_method_t
		
	Now all the files: dc1394/*.h are added. The special functions for the
	specific camera vendors and linux platform are skipped. Sometime they may
	come, but at the moment I think this much is enough for a start.

	All variable names are shortened by removing the dc1394 tag. If one wants,
	still can do:
	
	import _dc1394core as dc1394
	and use everything with dc1394.video_frame_t or similar.

	Shutter, converting to ms: this is only meaningful if the camera is
	absolute capable. Otherwise this is just a number, but the camera manual
	may provide some conversion to it. The multiplication would only
	complicate life in such a case.

	Added the "vendor" and "model" keys to the cameralist returned by the
	DC1394Library.enumerate_cameras(). The function opens each camera after
	enumeration and gets these values from the camere descriptor. This way the
	user may have a clue in advance which camera is which (when there is more
	than one).

2010 Feb. 10:
	Followed up the changes induced by the ones made in the core library. Now
	it seems the system runs, the camera can take shots, and the basic
	functionality did not change. For some reason I had some problems with the
	_dtype part of the Camera class. I added an inocent declaration to the
	__init__ function, and it runs fine.
	In FORMAT7 mode now the camera mode changes to (0,0, FORMAT7_...), because
	the real shape strongly depends on the ROI and the camera. Anyway the
	current program_format7_mode takes care of setting the shape parameter
	properly.

2010 Feb. 11:
    Dumping files: latter, may be implemented. The pgm format is easy to dump,
    and universal enough for most applications (8 and 16 bit gray scale ones).

2010 Feb. 12:
    Interesting NULL pointer access at the DC1394Library.enumerate_cameras,
    when accessing vendor or model informations. Now added a test that they
    should be used only when not NULL pointers.

    Also found some places where the new ..._codes dict can be used, and the
    for... taken over by a ..._codes.has_key() function.

    It is a bit weird why the trigger_source_vals... is trigger_source_0_vals.
    Now it is set to the simpler version: trigger_source_vals.
    
    Added trigger_polarity, trigger_source, trigger.pos_polarities,
    trigger.pos_sources.

    Interestingly, the trigger_get_polarity returns 1, which should be 704 or
    705. There must be something wrong.
        Some various resources, such as the help page of the dc1394 library
        itself states 0 and 1 as the values. The control.c of the dc1394
        library itself tests for True and False values only, and does not even
        use this enum. For now let us fall back to this in the _dc1394core
        until something else comes up.
    
    Added the software_trigger variable as well. Its possible values are True
    and False.

2010 Feb. 15:
    A bit of work on the format7 mode. Problem: the (0,0) is justified in the
    core lib, but not in the mode setting. One needs the actual camera image
    size to return valid numbers for the images. Otherwise the whole thing
    goes to hell in format7 mode.
    And format7 is the mode sometimes we do want.

    So, the Camera.mode now checks for format7, and if such one is set, it
    requests the maximal resolution from the camera. Then sends it back. This
    may be not optimal, perhaps the actual image size would be better. The
    issue between the Camera.program_format7_mode() and this has to be
    resolved.
    
    The problem is: for some reason the ROI setting messes the whole up on the
    HAMAMATSU ORCA which was used for testing. Why?

2010 Feb. 17:
    Most of the strange error messages came with color_coding. So, let us
    check the color coding. Added a part to the Camera.program_format7_mode:
    - read out the current color coding
    - is another one requested?
    - is this other one supported by the given mode? Then set it
    - or leave the current one, and set the ROI

    Another issue may come up: the image position and size has a unit, which
    is the minimum step to use for setting them. It may be different from 1.
    At the moment this is not tested when the ROI is set. Actually the ROI is
    equivalent with setting the image size and offset separately.

2010 Feb. 19:
    Camera.mode _dtype settings: both gray scale and RGB have 8 bit and 16
    bit possibilities. Therefore to define the proper data type of the image,
    one has to check if '8' or '16' are present in the color coding, and then 
    if RGB is present.
    For the case of YUV modes the YUV422 the pixel is 16 bits, for YUV411
    it is 12 bits, but the image has to be converted... At the moment the
    Camera.mode sets unsigned 8 bit integer, and displays a warning.

    Also add some docstrings to the various functions.

    Framerate, isospeed, video mode:
    All functions use an internal variable to store the desired value.
    These are actually set to the camera when the capture stars with the
    Camera.start() function. Thus they are off synch until a Camera.start() is
    called.

    This also means, that all features may be asked about video modes and
    properties which are actually not set, only tested if those values are
    theoretically in the available range.

    Fortunately the dc1394 seems to allow such testing, as one can see it with
    the FORMAT7 video mode, where the image size is asked from the camera.

    A little bug with the Camera.mode.fset(): the provided mode was tested as
    a text before a possible tupple was converted to text. Now this is fixed.

    #a test run: try with direct feature setting; so far it looks fine:
    standard mode setting, framerate changing, isospeed, etc. works.
    With the new version the reported values and features are in synch with
    the camera.

2010. Feb. 20:
    Camera.isospeed: the operation mode setting is now here, with exception
    handling.

    Added unit tests to the program_format7_mode(). Also the Camera._dtype is
    handled by the mode changing, so that is not needed here anymore.
    
    The returned fps value is not correct for the FORMAT7 mode. This has to be
    double checked.

2010 Feb. 22:
    One of our camera does not respond to trigger mode changes, and does not
    allow changes in the trigger mode... Weird.
    Anyway: the fset of the modes should check agains the available modes, not
    the whole dict of possible values.
    Bug: after setting the trigger mode, the program did not return: the else
    statement was missing: -> fixed and simplified.
